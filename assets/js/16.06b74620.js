(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{171:function(n,s,t){"use strict";t.r(s);var a=t(0),r=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var n=this,s=n.$createElement,t=n._self._c||s;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"javascrip的异步理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascrip的异步理解","aria-hidden":"true"}},[n._v("#")]),n._v(" Javascrip的异步理解")]),n._v(" "),t("p",[n._v("标签（空格分隔）： 未分类")]),n._v(" "),t("hr"),n._v(" "),t("p",[n._v("由于js的执行环境是单线程的，为什么他是单线程的呢？\n其实js一开始作为脚本语言，主要用途是与用户互动，以及操作DOM也就决定了他只能是单线程的。\n什么叫单线程？所谓单线程就是说，在同一个时间内，只能做一件事，就叫多线程。如果有多个任务，那么就需要排队，等前面的一个任务完成后，在执行下一个任务。")]),n._v(" "),t("p",[n._v("单线程的好处：\n这种模式的好处是实现起来相对简单，执行环境相对单纯。\n单线程的坏处：\n如果又一个任务需要很久才能执行完，那么这个程序可能回花费很长的时间才能执行完。比如浏览器卡死的情况就会发生。")]),n._v(" "),t("p",[n._v("为了解决这个问题，js将任务分作两种。\n"),t("em",[t("strong",[n._v("同步任务（Synchronous）和异步任务（Asynchronous）")])])]),n._v(" "),t("p",[n._v("##同步任务（Synchronous）\n下一个任务必须等待前一个任务完成后才能执行，就好比一个人，同一个时间，只能做一件事情，做完一件再做下一件（一心一意）。\n##异步任务（Asynchronous）\n每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。（阮一峰说的）")]),n._v(" "),t("p",[n._v("##js任务的运行机制\n在执行一个程序时，有多个任务任务分为同步任务和异步任务，所以的同步任务都进入主线程排队，等待着前一个任务完成再执行。而所有的异步任务都会进入任务队列中。每一个异步任务有结果后，就会在任务队列中放置一个事件，用来告诉主线程，我这个异步任务已经有结果了，可以放在主线程里运行了。\n当主线程的所有同部任务执行完后，系统就会去任务队列中看，看有那些事件，然后将对应的异步任务加入到主线程中去。\n主线程会不断重复去任务队列中查看的操作。")]),n._v(" "),t("p",[n._v("生命周期中的任何异步操作，都不会按照顺序执行，他会在非异步操作结束后执行，因此书写这部分代码的时候请注意里面的逻辑不要和顺序挂钩，要确保任何异步操作即使最后执行，之前的程序也不会发生异常从而阻塞整个进程。")])])}],!1,null,null,null);r.options.__file="Javascrip的异步理解.md";s.default=r.exports}}]);